an identifier is a name that identifies (that is labels the identity of) either a unique object or a unique class of objects where the object or class may be an idea physical [countable] object (or class thereof) or physical [noncountable] substance (or class thereof) the abbreviation id often refers to identity identification (the process of identifying) or an identifier (that is an instance of identification) an identifier may be a word number letter symbol or any combination of those
the words numbers letters or symbols may follow an encoding system (wherein letters digits words or symbols stand for (represent) ideas or longer names) or they may simply be arbitrary when an identifier follows an encoding system it is often referred to as a code or id code identifiers that do not follow any encoding scheme are often said to be arbitrary ids they are arbitrarily assigned and have no greater meaning (sometimes identifiers are called codes even when they are actually arbitrary whether because the speaker believes that they have deeper meaning or simply because he is speaking casually and imprecisely.)
id codes inherently carry metadata along with them (for example when you know that the food package in front of you has the identifier 2011-09-25t15:42z-mfr5-p02-243-45 you not only have that data you also have the metadata that tells you that it was packaged on september 25 2011 at 3:42pm utc manufactured by licensed vendor number 5 at the peoria il usa plant in building 2 and was the 243rd package off the line in that shift and was inspected by inspector number 45.) arbitrary identifiers carry no metadata (for example if your food package just says 100054678214 its id may not tell you anything except identityno date manufacturer name production sequence rank or inspector number.)
in some cases even arbitrary identifiers such as sequential serial numbers leak too much information (see german tank problem) opaque identifiersidentifiers designed to avoid leaking even that small amount of informationinclude really opaque pointers and version 4 uuids
the unique identifier (uid) is an identifier that refers to only one instanceonly one particular object in the universe a part number is an identifier but it is not a unique identifierfor that a serial number is needed to identify each instance of the part design thus the identifier model t identifies the class (model) of automobiles that ford's model t comprises whereas the unique identifier model t serial number 159,862 identifies one specific member of that classthat is one particular model t car owned by one specific person
the concepts of name and identifier are denotatively equal and the terms are thus denotatively synonymous but they are not always connotatively synonymous because code names and id numbers are often connotatively distinguished from names in the sense of traditional natural language naming for example both jamie zawinski and netscape employee number 20 are identifiers for the same specific human being but normal english-language connotation may consider jamie zawinski a name and not an identifier whereas it considers netscape employee number 20 an identifier but not a name this is an emic indistinction rather than an etic one
== metadata ==
in metadata an identifier is a language-independent label sign or token that uniquely identifies an object within an identification scheme
the suffix identifier is also used as a representation term when naming a data element
== in computer science ==
in computer science identifiers (ids) are lexical tokens that name entities identifiers are used extensively in virtually all information processing systems identifying entities makes it possible to refer to them which is essential for any kind of symbolic processing
=== in computer languages ===
in computer languages identifiers are tokens (also called symbols) which name language entities some of the kinds of entities an identifier might denote include variables types labels subroutines and packages
which character sequences constitute identifiers depends on the lexical grammar of the language a common rule is alphanumeric sequences with underscore also allowed and with the condition that it not begin with a digit (to simplify lexing by avoiding confusing with integer literals) so foo foo1 foo_bar _foo are allowed but 1foo is not this is the definition used in earlier versions of c and c++ python 2 and many other languages later versions of these languages along with many other modern languages support almost all unicode characters in an identifier however a common restriction is not to permit whitespace characters and language operators this simplifies tokenization by making it free-form and context-free for example forbidding + in identifiers (due to its use as a binary operation) means that a+b and a + b can be tokenized the same while if it were allowed a+b would be an identifier not an addition whitespace in identifier is particularly problematic as if spaces are allowed in identifiers then a clause such as if rainy day then 1 is legal with rainy day as an identifier but tokenizing this requires the phrasal context of being in the condition of an if clause some languages do allow spaces in identifiers however such as algol 68 and some algol variants for example the following is a valid statement real half pi which could be entered as real half pi (keywords are represented in boldface concretely via stropping) in algol this was possible because keywords are syntactically differentiated so there is no risk of collision or ambiguity spaces are eliminated during the line reconstruction phase and the source was processed via scannerless parsing so lexing could be context-sensitive
in most languages some character sequences have the lexical form of an identifier but are known as keywords for example if is frequently a keyword for an if clause but lexically is of the same form as ig or foo namely a sequence of letters this overlap can be handled in various ways these may be forbidden from being identifiers which simplifies tokenization and parsing in which case they are reserved words they may both be allowed but distinguished in other ways such as via stropping or keyword sequences may be allowed as identifiers and which sense is determined from context which requires a context-sensitive lexer non-keywords may also be reserved words (forbidden as identifiers) particularly for forward compatibility in case a word may become a keyword in future in a few languages e.g. pl/1 the distinction is not clear
for implementations of programming languages that are using a compiler identifiers are often only compile time entities that is at runtime the compiled program contains references to memory addresses and offsets rather than the textual identifier tokens (these memory addresses or offsets having been assigned by the compiler to each identifier)
in languages that support reflection such as interactive evaluation of source code (using an interpreter or an incremental compiler) identifiers are also runtime entities sometimes even as first-class objects that can be freely manipulated and evaluated in lisp these are called symbols
compilers and interpreters do not usually assign any semantic meaning to an identifier based on the actual character sequence used however there are exceptions
for example
in perl a variable is indicated using a prefix called a sigil which specifies aspects of how the variable is interpreted in expressions
in ruby a variable is automatically considered immutable if its identifier starts with a capital letter
in fortran the first letter in a variable's name indicates whether by default it is created as an integer or floating point variable
in go the capitalization of the first letter of a variable's name determines its visibility (uppercase for public lowercase for private)
in some languages such as go identifiers uniqueness is based on their spelling and their visibility
in html an identifier is one of the possible attributes of an html element it is unique within the document
== ambiguity ==
=== identifiers (ids) versus unique identifiers (uids) ===
many resources may carry multiple identifiers typical examples are
one person with multiple names nicknames and forms of address (titles salutations)
for example one specific person may be identified by all of the following identifiers jane smith jane elizabeth meredith smith jane e m smith jane e smith janie smith janie little janie (as opposed to her mother or sister or cousin big janie) aunt jane auntie janie mom grandmom nana kelly's mother billy's grandmother ms smith dr smith jane e smith phd and fuzzy (her jocular nickname at work)
one document with multiple versions
one substance with multiple names (for example cas index names versus iupac names inn generic drug names versus usan generic drug names versus brand names)
the inverse is also possible where multiple resources are represented with the same identifier (discussed below)
=== implicit context and namespace conflicts ===
many codes and nomenclatural systems originate within a small namespace over the years some of them bleed into larger namespaces (as people interact in ways they formerly hadn't e.g. cross-border trade scientific collaboration military alliance and general cultural interconnection or assimilation) when such dissemination happens the limitations of the original naming convention which had formerly been latent and moot become painfully apparent often necessitating retronymy synonymity translation/transcoding and so on such limitations generally accompany the shift away from the original context to the broader one typically the system shows implicit context (context was formerly assumed and narrow) lack of capacity (e.g. low number of possible ids reflecting the outmoded narrow context) lack of extensibility (no features defined and reserved against future needs) and lack of specificity and disambiguating capability (related to the context shift where longstanding uniqueness encounters novel nonuniqueness) within computer science this problem is called naming collision the story of the origination and expansion of the coden system provides a good case example in a recent-decades technical-nomenclature context the capitalization variations seen with specific designators reveals an instance of this problem occurring in natural languages where the proper noun/common noun distinction (and its complications) must be dealt with a universe in which every object had a uid would not need any namespaces which is to say that it would constitute one gigantic namespace but human minds could never keep track of or semantically interrelate so many uids
== identifiers in various disciplines ==
a small sample of various identifiers
== see also ==
== references ==
